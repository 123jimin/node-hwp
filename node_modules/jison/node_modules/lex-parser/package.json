{
  "name": "lex-parser",
  "version": "0.1.4",
  "description": "A parser for lexical grammars used by jison",
  "main": "lex-parser.js",
  "scripts": {
    "test": "make test"
  },
  "repository": {
    "type": "git",
    "repository": "https://github.com/zaach/lex-parser.git"
  },
  "keywords": [
    "lexical",
    "grammar",
    "parser",
    "jison"
  ],
  "author": {
    "name": "Zach Carter"
  },
  "license": "MIT",
  "devDependencies": {
    "jison": "0.4.x",
    "test": "*"
  },
  "readme": "# lex-parser\n\nA parser for lexical grammars used by [jison](http://jison.org) and jison-lex.\n\n## install\n\n    npm install lex-parser\n\n## build\n\nTo build the parser yourself, clone the git repo then run:\n\n    make\n\nThis will generate `lex-parser.js`.\n\n## usage\n\n    var lexParser = require(\"lex-parser\");\n\n    // parse a lexical grammar and return JSON\n    lexParser.parse(\"%% ... \");\n\n## example\n\nThe parser can parse its own lexical grammar, shown below:\n\n    NAME              [a-zA-Z_][a-zA-Z0-9_-]*\n\n    %s indented trail rules\n    %x code start_condition options conditions action\n\n    %%\n\n    <action>[^{}]+          return 'ACTION_BODY'\n    <action>\"{\"             yy.depth++; return '{'\n    <action>\"}\"             yy.depth == 0 ? this.begin('trail') : yy.depth--; return '}'\n\n    <conditions>{NAME}      return 'NAME'\n    <conditions>\">\"         this.popState(); return '>'\n    <conditions>\",\"         return ','\n    <conditions>\"*\"         return '*'\n\n    <rules>\\n+              /* */\n    <rules>\\s+              this.begin('indented')\n    <rules>\"%%\"             this.begin('code'); return '%%'\n    <rules>[a-zA-Z0-9_]+    return 'CHARACTER_LIT'\n\n    <options>{NAME}         yy.options[yytext] = true\n    <options>\\n+            this.begin('INITIAL')\n    <options>\\s+\\n+         this.begin('INITIAL')\n    <options>\\s+            /* empty */\n\n    <start_condition>{NAME}         return 'START_COND'\n    <start_condition>\\n+            this.begin('INITIAL')\n    <start_condition>\\s+\\n+         this.begin('INITIAL')\n    <start_condition>\\s+            /* empty */\n\n    <trail>.*\\n+                    this.begin('rules')\n\n    <indented>\"{\"                   yy.depth = 0; this.begin('action'); return '{'\n    <indented>\"%{\"(.|\\n)*?\"%}\"      this.begin('trail'); yytext = yytext.substr(2, yytext.length-4);return 'ACTION'\n    \"%{\"(.|\\n)*?\"%}\"                yytext = yytext.substr(2, yytext.length-4); return 'ACTION'\n    <indented>.+                    this.begin('rules'); return 'ACTION'\n\n    \"/*\"(.|\\n|\\r)*?\"*/\"             /* ignore */\n    \"//\".*                          /* ignore */\n\n    \\n+                             /* */\n    \\s+                             /* */\n    {NAME}                          return 'NAME'\n    \\\"(\"\\\\\\\\\"|'\\\"'|[^\"])*\\\"         yytext = yytext.replace(/\\\\\"/g,'\"');return 'STRING_LIT'\n    \"'\"(\"\\\\\\\\\"|\"\\'\"|[^'])*\"'\"       yytext = yytext.replace(/\\\\'/g,\"'\");return 'STRING_LIT'\n    \"|\"                             return '|'\n    \"[\"(\"\\\\\\\\\"|\"\\]\"|[^\\]])*\"]\"      return 'ANY_GROUP_REGEX'\n    \"(?:\"                           return 'SPECIAL_GROUP'\n    \"(?=\"                           return 'SPECIAL_GROUP'\n    \"(?!\"                           return 'SPECIAL_GROUP'\n    \"(\"                             return '('\n    \")\"                             return ')'\n    \"+\"                             return '+'\n    \"*\"                             return '*'\n    \"?\"                             return '?'\n    \"^\"                             return '^'\n    \",\"                             return ','\n    \"<<EOF>>\"                       return '$'\n    \"<\"                             this.begin('conditions'); return '<'\n    \"/!\"                            return '/!'\n    \"/\"                             return '/'\n    \"\\\\\"([0-7]{1,3}|[rfntvsSbBwWdD\\\\*+()${}|[\\]\\/.^?]|\"c\"[A-Z]|\"x\"[0-9A-F]{2}|\"u\"[a-fA-F0-9]{4}) return 'ESCAPE_CHAR'\n    \"\\\\\".                           yytext = yytext.replace(/^\\\\/g,''); return 'ESCAPE_CHAR'\n    \"$\"                             return '$'\n    \".\"                             return '.'\n    \"%options\"                      yy.options = {}; this.begin('options')\n    \"%s\"                            this.begin('start_condition');return 'START_INC'\n    \"%x\"                            this.begin('start_condition');return 'START_EXC'\n    \"%%\"                            this.begin('rules'); return '%%'\n    \"{\"\\d+(\",\"\\s?\\d+|\",\")?\"}\"       return 'RANGE_REGEX'\n    \"{\"{NAME}\"}\"                    return 'NAME_BRACE'\n    \"{\"                             return '{'\n    \"}\"                             return '}'\n    .                               /* ignore bad characters */\n    <*><<EOF>>                      return 'EOF'\n\n    <code>(.|\\n)+                   return 'CODE'\n\n    %%\n\n## license\n\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "lex-parser@0.1.4",
  "dist": {
    "shasum": "814786292f4a2c9785bbc630841b46982c444bf9"
  },
  "_from": "lex-parser@~0.1.3",
  "_resolved": "https://registry.npmjs.org/lex-parser/-/lex-parser-0.1.4.tgz"
}
